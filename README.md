# Project shell

**Demo video**

<a href="https://www.youtube.com/watch?v=l0e9i8zXcIs" target="_blank">
  <img src="https://img.youtube.com/vi/l0e9i8zXcIs/0.jpg" alt="Watch the video">
</a>


## Why the shell ?

` What I cannot create, I do not understand.
Know how to solve every problem that has been solved` ~ *Richard Feynman*

For every philosophy there is some truth to  it and for this one, I completely agree with this one.

A **shell** is a **Command Line-based Interface (CLI)** that enables the Operating System to communicate with the firmware inside a machine.

----

### With this project I learnt

- how [processes are managed by the OS](https://www.geeksforgeeks.org/introduction-of-process-management/)

- [system calls](https://www.geeksforgeeks.org/introduction-of-system-call/)

- [input/output handling](https://www.geeksforgeeks.org/introduction-to-input-output-interface/)

- [command parsing](https://bito.ai/resources/c-parse-string-c-string-explained/)

- [job control](https://ftp.gnu.org/old-gnu/Manuals/glibc-2.2.3/html_chapter/libc_27.html)

- [signal handling](https://medium.com/@razika28/signals-ad83f38f80b6)

- [file system interaction](https://www.geeksforgeeks.org/basics-file-handling-c/
)
- [error handling](https://www.geeksforgeeks.org/error-handling-in-c/)

----
As much as I  love [history](https://developer.ibm.com/tutorials/l-linux-shells/), am not trying to bore you with a lecture on it and so let's get started with building structure.

## Roadmap

I created a *14-day roadmap* which I used to create a shell and I would like to share it since its simple and reduces the workload when it comes to research and creating your own shell.